#include <avr/io.h>#include <avr/eeprom.h>/*Ardupilot 2.5.0 Waypoint writerUse this release to:	- Manually upload waypoints	- write new defaults to the EEPROM	- Verify the stored waypoints*/// Do you want to overwrite your launch params and options with defaults?#define WRITE_DEFAULTS 1 // 1 = yes, 0 = no#define WRITE_WAYPOINTS 1 // 1 = yes, 0 = no// User options:#define LOOP_WAYPOINTS 	0 // # of times around the pattern#define waypoint_mode  	0 // 1 = relative, 0 = absolute  (not implemented yet)// How many points are you entering?#define WP_TOTAL 		13#define ABSOLUTE_WAYPOINTS 1 // 0 = relative, 1 = absolute// Edit this Area to save waypoints// first entry is waypoint 1// ONLY FIRST 5 DECIMAL PLACES CAN BE TRUSTED!///*float wayPoints[WP_TOTAL][3] = {	{37.7162310,-122.3812040,100}, 	// 1		{37.7177670,-122.3798630,75},	// 2	{37.7173770,-122.3831250,50},	// 3	{37.7188620,-122.3817940,25},	// 4	{37.7162310,-122.3812040,50},	// 5	{37.7177670,-122.3798630,75},	// 6	{37.7173770,-122.3831250,100},	// 7	{37.7188620,-122.3817940,75},	// 8	{37.7162310,-122.3812040,50},	// 9	{37.7177670,-122.3798630,25},	// 10	{37.7173770,-122.3831250,50},	// 11	{37.7188620,-122.3817940,75},	// 12	{37.7162310,-122.3812040,100}	// 13};/*float wayPoints[WP_TOTAL][3] = {	{-0.000465,-0.000612,100},		// 1		{0.000456,-0.000628,75},		// 2	{-0.000453,0.000558,50},		// 3	{0.000456, 0.000536,25},		// 4	{-0.000465,-0.000612,50},		// 5	{0.000456,-0.000628,75},		// 6	{-0.000453,0.000558,100},		// 7	{0.000456, 0.000536,75},		// 8	{-0.000465,-0.000612,100},		// 9	{0.000456,-0.000628,75},		// 10	{-0.000453,0.000558,50},		// 11	{0.000456, 0.000536,25},		// 12	{-0.000465,-0.000612,100},		// 13};*//*float wayPoints[WP_TOTAL][3] = {	{45.5665880, 8.9975500,25}, 	// 1		{45.5669520, 8.9980400,25},	// 2	{45.5675520, 8.9978600,25},	// 3	{45.5677480, 8.9971400,25},	// 4};*//*float wayPoints[WP_TOTAL][3] = {	{-26.1511520, 27.9781490, 30},	{-26.1525490, 27.9776500, 30},};*/// no need to edit below this line// -------------------------------#define WP_10_BYTES 10#define WP_START_BYTE 0x18// 3D Location vectors// -------------------struct Location {        long lat;        long lng;        long alt;};const long t7 = 10000000;	// used to scale GPS values for EEPROM storageconst long t6 = 1000000;	// used to scale GPS values for EEPROM storagebyte wp_total;struct Location home 				= {37981856, -122362375, 0};		// home locationvoid setup(){	Serial.begin(38400);	delay(500);	Serial.println("Waypoint writer");#if WRITE_DEFAULTS == 1		writeDefaults(); // saves default values to system#endif#if WRITE_WAYPOINTS == 1		writePoints();  // saves Waypoint Array#endif	eeprom_busy_wait();	byte options = eeprom_read_byte((uint8_t *)	0x00);	eeprom_busy_wait();	int hold = eeprom_read_word((uint16_t *)	0x16);	Serial.print("options:");	Serial.println(options, BIN);	Serial.print("Alt to hold:");	Serial.println(hold ,DEC);	delay(1000);	readPoints();	Serial.print("total # of points:");	Serial.println(wp_total ,DEC);}void loop(){}void writePoints(){	    int mem_position;	struct Location loc;	// number of waypoints	wp_total = WP_TOTAL;		// save # of points	eeprom_busy_wait();	eeprom_write_byte((uint8_t *)	0x09, wp_total);	// save index	eeprom_busy_wait();	eeprom_write_byte((uint8_t *)	0x0A, 0);	//set home as 0	eeprom_write_dword((uint32_t *)	0x0E, 0);	eeprom_busy_wait();	eeprom_write_dword((uint32_t *)	0x12, 0);	eeprom_busy_wait();	eeprom_write_word((uint16_t *)	0x0C, 0);		    for (byte i = 0; i < wp_total; i++){    	    	loc.lat = (long)(wayPoints[i][0] * t6);    	loc.lng = (long)(wayPoints[i][1] * t6);    	loc.alt = 0;    	loc.alt = (int)wayPoints[i][2];    	Serial.print((i+1),DEC);    	Serial.print(": ");    	Serial.print(loc.lat,DEC);    	Serial.print(", ");    	Serial.print(loc.lng,DEC);    	Serial.print(", ");    	Serial.println(loc.alt,DEC);    	mem_position = (int)(WP_START_BYTE) + (i * WP_10_BYTES);    	eeprom_busy_wait();				eeprom_write_dword((uint32_t *)	mem_position, loc.lat);		eeprom_busy_wait();		mem_position += 4;		eeprom_write_dword((uint32_t *)	mem_position, loc.lng);		eeprom_busy_wait();		mem_position += 4;		eeprom_write_word((uint16_t *)	mem_position, (int)loc.alt);	}	}void readPoints(){	eeprom_busy_wait();	wp_total = eeprom_read_byte((uint8_t *)	0x09);	    for (byte i = 1; i <= wp_total; i++){		#if ABSOLUTE_WAYPOINTS == 1    		struct Location temp = get_loc_with_index(i);		#else	    	struct Location temp = get_rel_loc_with_index(i);		#endif		Serial.print("waypoint # ");		Serial.print(i,DEC);		Serial.print("\tlat: ");		Serial.print(temp.lat,DEC);		Serial.print("\tlong: ");		Serial.print(temp.lng,DEC);		Serial.print("\talt: ");		Serial.println(temp.alt,DEC);	}}void writeDefaults(void){	eeprom_busy_wait();	eeprom_write_byte((uint8_t *)	0x3E7, waypoint_mode);	eeprom_busy_wait();	// 0 = abs, 1 = relative	eeprom_write_byte((uint8_t *)	0x3E6, LOOP_WAYPOINTS);	eeprom_busy_wait(); // 0 = return home after 1 trip	eeprom_write_word((uint16_t *)	0x01,  288);			eeprom_busy_wait();	// air_speed_offset	eeprom_write_word((uint16_t *)	0x3E4, 200);			eeprom_busy_wait();	// ir_max 	eeprom_write_word((uint16_t *)	0x3D6, 1500);	eeprom_busy_wait();	// ch1_trim	eeprom_write_word((uint16_t *)	0x3D8, 1500);	eeprom_busy_wait();	// ch2_trim	eeprom_write_word((uint16_t *)	0x3DA, 1024);	eeprom_busy_wait(); // ch3_trim	eeprom_write_word((uint16_t *)	0x3DC, 1100);	eeprom_busy_wait(); // ch1_min	eeprom_write_word((uint16_t *)	0x3DE, 1900);	eeprom_busy_wait(); // ch1_max	eeprom_write_word((uint16_t *)	0x3E0, 1041);	eeprom_busy_wait(); // ch2_min	eeprom_write_word((uint16_t *)	0x3E2, 1765);	eeprom_busy_wait(); // ch2_max}struct Location get_loc_with_index(int i){	struct Location temp;	long mem_position;	// Find out proper location in memory by using the start_byte position + the index	// --------------------------------------------------------------------------------	if (i == 0) {		// read home position 		eeprom_busy_wait();		temp.lat = (long)eeprom_read_dword((uint32_t*)0x0E);eeprom_busy_wait();		temp.lng = (long)eeprom_read_dword((uint32_t*)0x12);eeprom_busy_wait();		temp.alt = 0;		temp.alt = (long)eeprom_read_word((uint16_t*)0x0C);		temp.lat *= 10;		temp.lng *= 10;		temp.alt *= 100;				return temp;			}else{		// read WP position 		mem_position = (long)(WP_START_BYTE + (i-1) * WP_10_BYTES);		eeprom_busy_wait();		temp.lat = (long)eeprom_read_dword((uint32_t*)mem_position);		mem_position += 4;		eeprom_busy_wait();		temp.lng = (long)eeprom_read_dword((uint32_t*)mem_position);		mem_position += 4;		temp.alt = 0;		eeprom_busy_wait();		temp.alt = (long)eeprom_read_word((uint16_t*)mem_position);				temp.lat *= 10;		temp.lng *= 10;		temp.alt *= 100;				return temp;	}}struct Location get_rel_loc_with_index(int i){	struct Location temp = get_loc_with_index(i);		temp.lat += home.lat;	temp.lng += home.lng;	return temp;}